---
title: 'REST: Architecture Style'
categories: Dev
date: 2018-04-19 11:39:32
tag:
- HTTP
- Web
- REST
---
{% callout info %}
#### {% fa info-circle %} 출처: <웹 개발자를 위한 웹을 지탱하는 기술>
{% endcallout %}

## 01. 아키텍처 스타일의 중요성

> REST는 웹의 아키텍처 스타일입니다. 아키텍처 스타일은 아키텍처 패턴이라고도 하며, 복수의 아키텍처의 공통된 성질, 양식, 규정 혹은 독특한 방식을 가리키는 말입니다.

아키텍처를 설계할 때, 그냥 마구잡이로 만들어 가는 것이 아니라 아키텍처 설계 지침, 규정 , 방식 즉, 아키텍처 스타일을 적용합니다. 시스템의 아키텍처를 결정할 때 나침반이 되는 것이 아키텍처 스타일입니다.

### 아키텍처 스타일의 종류

* MVC(Model-View-Controller)
* Pipe and Filter
* Event System

---


## 02. 아키텍처 스타일로서의 REST

네트워크 시스템의 아키텍처 스타일로서 가장 유명한 것은 **클라이언트/서버**입니다. 그리고 REST는 클라이언트/서버 구조에서 파생된 아키텍처 스타일입니다. 순수한 클라이언트 서버 아키텍처 스타일에 `몇 가지 제약`을 더해가면 **REST 아키텍처 스타일**이 됩니다.

일반적으로 소프트웨어 아키텍처는 복수의 컴포넌트를 조합해 구현하는데, 각각의 컴포넌트가 따로따로 움직여서는 동작하지 않습니다. 그래서 각 컴포넌트에 제약을 부과해 갑니다. 그 결과, 전체적으로 각 컴포넌트가 협력하면서 동작합니다.

| 추상화 레벨     | 웹에서의 예                             |
| --------------- | --------------------------------------- |
| 아키텍처 스타일 | REST                                    |
| 아키텍처        | Browser, Server, Proxy, HTTP, URI, HTML |
| 구현            | Apache, Firefox, Internet Explorer      |

REST는 웹 전체의 아키텍처 스타일이기도 하며, 개별 웹 서비스와 웹 API의 아키텍처 스타일이기도 합니다.

---

## 03. 리소스

> 1. 리소스란 웹상의 이름을 가진 정보를 의미한다.
> 2. 전 세계의 무수한 리소스는 각각 URI로 의미 있는 이름을 가진다.
> 3. URI를 이용함으로써, 프로그램은 리소스가 표현하는 정보에 접근할 수 있다.



리소스란 **웹 상에 존재하는 이름을 가진 모든 정보**입니다. 다른 것과 구별하기 위해 리소스는 이름이 필요합니다. 때문에 리소스는 이름을 가지고, 리소스의 이름을 URI라고 합니다.



### 리소스의 어드레스 가능성

URI가 지니고 있는 리소스를 간단히 가리킬 수 있는 성질을 **어드레스 가능성(Addressability)** 라고 부릅니다. 즉, 제대로 이름이 붙어 있고, 적절한 수단으로 접근할 수 있는 상태로 만들면, 프로그램을 만들기가 아주 쉬워집니다.



### 복수의 URI를 가진 리소스

1개의 리소스는 복수의 URI를 가질 수 있습니다. 예를 들어 오늘이 2010년 1월 1일이라고 하면, 2개의 URI는 같은 리소스를 가리킵니다.

> http://weather.example.com/seoul/today
> http://weather.example.com/seoul/2010-01-01

하나의 리소스에 URI를 여러 개 붙여 두면, 클라이언트가 리소스에 접근하기가 쉬워집니다. 

반면, 어느 것이 정식 URI인지 알기 힘들다는 결점도 동시에 가집니다.



### 리소스의 표현과 상태

* 리소스는 서버와 클라이언트 간에 실제로 리소스를 주고 받을 때는 어떤 구체적인 데이터를 서로 송 신합니다. 서버와 클라이언트 사이에 주고받는 데이터를 **Resource Representation**이라고 부릅니다.
* 하나의 리소스는 복수의 표현을 가질 수 있습니다. 예를 들어 일기예보 리소스는 HTML, TEXT, PDF, Image 형식 등으로도 표현할 수 있습니다.
* 또한 리소스에는 **상태**라는 것이 있는데, 시간의 경과에 따라 리소스의 상태가 변하면 그 표현도 변합니다. 현재 일기 예보가 '맑음'이라도 몇 시간 후에는 '흐림'으로 상태가 변하는 것이 그 예입니다.

---

## 04. REST의 종류

1. 클라이언트/서버: 유저 인터페이스와 처리를 분리.
2. 스테이트리스 서버: 서버 측에서 애플리케이션의 상태를 가지지 않음.
3. 캐시: 클라이언트와 서버의 통신횟수와 양을 감소시킴.
4. 유니폼 인터페이스: 인터페이스를 고정.
5. 계층화 시스템: 시스템을 계층별로 분리.
6. 코드 온 디맨드: 프로그램을 클라이언트에 다운로드하여 실행.



### 1) 클라이언트/서버

웹은 HTTP라는 프로토콜을 이용해 클라이언트와 서버가 서로 통신하는 클라이언트/서버의 아키텍처 스타일을 채용하고 있습니다. 즉, 클라이언트가 서버에 Request하면, 서버는 클라이언트에 대해 Response을 돌려줍니다.



![Client Server](https://raw.githubusercontent.com/likedemian/Private-Studies/master/HTTP%2C%20URI%2C%20HTML%2C%20REST/Client-Server.png)



#### 클라이언트/서버의 이점 

* 단일 컴퓨터 상에서 모든 것을 처리하는 것이 아니라, **클라이언트와 서버로 분리해서 처리할 수 있습니다**. 이렇게 하면, 클라이언트를 멀티 플랫폼으로 구성할 수 있는데, 가령 웹을 PC 뿐 아니라 휴대전화나 게임기를 통해서도 접속할 수있는 것이 그 예입니다.
* 클라이언트에서 User Interface를 담당하기 때문에 서버는 Data Storage 기능만을 제공하면 됩니다. 나아가 복수의 서버를 조합해 확장함으로써 가용성을 올릴 수 있습니다.



### 2) 스테이트리스 서버

클라이언트/서버에 최초로 추가할 아키텍처 스타일은 **스테이트리스 서버**입니다(여기서 스테이트리스란, **클라이언트의 애플리케이션 상태를 서버에서 관리하지 않는다**는 것을 의미합니다).



#### 스테이트리스 서버의 이점

* 서버가 애플리케이션의 상태를 가지지 않게 되면, 서버 측의 구현을 간략화할 수 있는 장점이 있습니다. 간략하게 구현된 서버는 클라이언트로부터의 요청에 응답한 뒤 바로 서버의 자원을 해제할 수 있습니다. 



현실에서는 스테이트리스가 아닌 웹 서비스와 웹 API가 많습니다. 특히 HTTP를 스테이트풀하게 만드는 대표적인 것은 Cookie를 사용한 세션 관리입니다. 

REST의 관점에서 본다면, Cookie를 사용한 세션 관리는 HTTP의 잘못된 확장입니다. 그렇다고 REST의 기준으로 잘못되었다고 해서, Cookie를 사용한 폼 인증을 그만둘 수 없는 것도 현실입니다.  **Cookie는 스테이트리스 서버의 이점을 버린다는 것을 이해한 후에 최소한으로 이용합시다.**

![Client Stateless](https://raw.githubusercontent.com/likedemian/Private-Studies/master/HTTP%2C%20URI%2C%20HTML%2C%20REST/Client-Stateless.png)



### 3) 캐시

캐시란 리소스의 신선도에 기초해, **한 번 가져온 리소스를 클라이언트 쪽에서 돌려쓰는 방식**입니다. 



#### 캐시의 장점

* 서버와 클라이언트 사이의 통신량을 줄여 네트워크 대역의 이용과 처리시간을 축소해, 효율적으로 처리할 수 있습니다.




캐시를 추가한 아키텍처 스타일은 **클라이언트/캐시/스테이트리스 서버**입니다.



![Client Cache Stateless](https://raw.githubusercontent.com/likedemian/Private-Studies/master/HTTP%2C%20URI%2C%20HTML%2C%20REST/Client-Cache-Stateless.png)



### 4) 유니폼 인터페이스

유니폼 인터페이스는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일입니다(ex. HTTP 1.1는 GET과 POST 등 8개의 메서드만 정의되고, (보통) 이 이상 늘어나지 않습니다).

메서드가 8개로 고정되어 확장할 수 없는 것은 아주 엄격한 제약처럼 느껴지지만, 인터페이스의 유연성에 제약을 가함으로써 **전체적인 아키텍처가 간결해집니다**. 또한 인터페이스를 통일함으로써 **클라이언트와 서버 구현의 중립성이 향상**됩니다. 현재의 웹이 다양한 클라이언트와 서버로 구성되어 있는 데에는 유니폼 인터페이스가 큰 역할을 담당했습니다. 유니폼 인터페이스는 REST를 가장 특징짓는 아키텍처 스타일입니다.



유니폼 인터페이스를 추가한 아키텍처 스타일을 **유니폼/클라이언트/캐시/스테이트리스 서버**라고 합니다.



![Uniform Client Cache Stateless](https://raw.githubusercontent.com/likedemian/Private-Studies/master/HTTP%2C%20URI%2C%20HTML%2C%20REST/Uniform-Client-Cache-Stateless.png)



### 5) 계층화 시스템

유니폼 인터페이스의 이점 가운데 하나로, **시스템 전체를 계층화하기 쉽다**는 점을 들 수 있습니다. 

예를 들면, 웹 서비스에서는 서버와 클라이언트 간의 로드 밸런서를 설치해 부하를 분산시키거나 프록시를 설치해 액세스를 제어합니다. **클라이언트 측에서 보면, 서버나 프록시 모두 동일한 인터페이스로 접속할 수 있기 때문에 접속할 곳이 서버에서 프록시로 바뀐 것을 신경쓸 필요가 없습니다**. 이것은 서버와 프록시 등 각 컴포넌트 간의 인터페이스를 HTTP로 통일하고 있기에 실현될 수 있었습니다.

또한 기간계 레거시 시스템 등 HTTP의 인터페이스를 구현하지 않는 시스템에서도 레거시 시스템 앞단에 웹 애플리케이션 서버를 끼워 넣고 HTTP의 인터페이스를 가지게 함으로써 브라우저 등의 클라이언트와 접속할 수 있게 됩니다.

이처럼 **시스템을 몇 개의 계층으로 분리하는 아키텍처 스타일을 계층화 시스템**이라고 합니다.

계층화 시스템을 추가한 아키텍처 스타일을 **유니폼/계층화/클라이언트/캐시/스테이트리스 서버**라고 부릅니다.

![Uniform Layerd Client Cache Stateless Server](https://raw.githubusercontent.com/likedemian/Private-Studies/master/HTTP%2C%20URI%2C%20HTML%2C%20REST/Uniform%20Layered%20Client%20Cache%20Stateless.png)



### 6) 코드 온 디맨드

코드 온 디맨드는 프로그램 코드를 서버에서 다운받아 클라이언트에서 실행하는 아키텍처 스타일입니다( Javascript나 Flash, Java 애플릿 등이 여기에 해당합니다). 

#### 코드 온 디맨드의 장점

* 차후에 클라이언트를 확장할 수 있습니다. 클라이언트 프로그램에 미리 준비해 둔 기능 뿐만 아니라, 새로운 기능을 계속 추가할 수 있습니다. Javascript와 Flash를 풍부하게 사용한 화려한 웹 서비스는 코드 온 디맨드의 혜택을 입고 있습니다.

#### 코드 온 디맨드의 결점

* 네트워크 통신에서의 포로토콜 가시성이 저하됩니다. 
  * HTTP라는 애플리케이션 프로토콜에 따라 통신하고 있는 동안은 통신의 의미와 접근할 리소스가 명백하지만 코드 온 디맨드로 프로그램을 다운로드하여 클라이언트에서 실행하면 애플리케이션 프로토콜의 가시성은 저하됩니다.



코드 온 디맨드를 추가한 아키텍처 스타일을 **유니폼/계층화/코드온 디맨드/클라이언트/캐시/스테이트리스 서버**라고 합니다.

![Uniform Layerd Code on Demand Client Cache Stateless Server](https://raw.githubusercontent.com/likedemian/Private-Studies/master/HTTP%2C%20URI%2C%20HTML%2C%20REST/Uniform%20Layerd%20code%20on%20Demand%20Client%20Cache%20Stateless%20Server.png)



> REST는 아키텍처 스타일이므로 시스템을 설계할 때는 그 시스템의 아키텍처를 만들어야만 합니다. REST에 기초한 아키텍처를 구축할 경우라도 REST를 구성하는 스타일 중 몇 가지를 제외하더라도 상관없습니다. 예를 들어, 쿠키 정보 등을 통해 세션에 값을 저장하도록 하여 스테이트풀 하지만, URI 형식 등은 REST의 제약에 따르는 아키텍처도 생각해 볼 수 있습니다. 
>
> 이것은 말 그대로 설계 작업입니다. 소프트웨어와 시스템의 설계에서는 아키텍처 스타일의 이상과 타협해야만 하는 부분도 나오겠지요. 이상을 염두에 두면서 실제로 동작하고 가치를 제공할 수 있는 시스템을 만드는 것이 중요합니다.
>
> 무엇보다도 대부분의 REST 스타일을 제외해야만 하는 경우에 무리하게 REST를 채용할 필요가 없습니다.그런 시스템에는 보다 적합한 다른 아키텍처 스타일이 있기 때문입니다. 서버를 거치지 않고, 피어 사이에서의 통신이 필요한 경우는 REST보다 P2P 쪽이 좋겠지요.

---

## 05. REST의 2가지 측면

### REST와 하이퍼미디어

#### 애플리케이션 상태

* 예를 들어 소셜 북마크 애플리케이션의 이용자가 가지는 상태를 말합니다. '북마크 목록을 표시한다', '새로운 북마크 추가' 등의 상태가 구체적인 예입니다. 
* 애플리케이션 상태는 하이퍼미디어의 링크에 의해 변합니다. 하이퍼미디어가 **애플리케이션 상태 엔진**이라고 불리는 까닭입니다.

#### 하이퍼미디어를 이용한 애플리케이션의 장점

* 리소스의 URI만 알면 어떤 애플리케이션이 제공하고 있는 리소스를 다른 애플리케이션에서도 간단히 재사용할 수 있습니다(뉴스 사이트나 개발자용 도큐먼트 같은 다른 목적의 애플리케이션 리소스를 북마크 함으로써 리소스의 URI를 소셜 북마크에서 재이용한다고 생각할 수 있습니다).

> 리소스를 링크로 연결하여 하나의 애플리케이션을 구성한다는 개념은 REST의 근간을 이루는 사상입니다. 
>
> 이 개념은 '접속성'이라고도 불립니다.



### REST와 분산 시스템

RPC와 CORBA, DCOM 등의 분산 오브젝트에서는 함수나 메서드 단위로 서버 쪽의 처리를 호출합니다. 네트워크를 통한 함수 호출은 동일 프로세스 내의 함수 호출과는 비교되지 않을 만큼 오버헤드가 심하기 때문에 호출 횟수가 많아질수록 시스템 전체 성능의 저하를 가져옵니다. 

오버헤드로 인한 성능 저하 문제는 이론적으로는 인터페이스의 입도를 크게 하고 호출 횟수를 줄임으로써 회피할 수 있긴 하지만 실제로 구현하기는 쉽지 않습니다. 왜냐하면 RPC와 분산 오브젝트는 서버마다 다른 인터페이스를 가지며, 개별 인터페이스는 프로그램 라이브러리의 인터페이스를 기반으로 개발하는 경우가 많기 때문입니다. 일반적으로 라이브러리에 좋다는 인터페이스는 네트워크로 호출하기에는 지나치게 작은 입도입니다.



그에 비해 REST에 기초한 웹 서비스는 링크를 이용하여 애플리케이션을 실현합니다. 리소스는 그 자체로 의미를 가진 하나의 데이터이고, 따라서 RPC 함수에 의해 주고받는 데이터보다 입도가 큽니다. 그러므로 링크를 따라 애플리케이션의 상태를 변화시키는 편이 전체적인 성능 저하를 억제할 수 있습니다.

또한, RPC와 분산 시스템에서는 기능을 추가해 버전 업 할 때마다 메서드가 늘어나거나 메서드의 인수와 반환값이 바뀌어 API 호환성이 상실됩니다. 때문에 기존의 클라이언트를 모두 동시에 변경해야 됩니다.

그에 반해, REST에 기초한 웹에서는 유니폼 인터페이스에 의해 인터페이스가 고정되어 있기 때문에 호환성 문제가 발생하지 않습니다. 리소스에 적용할 수 있는 HTTP 메서드는 항상 고정되어 있어, HTTP를 구현한 클라이언트라면 동일하게 접속할 수 있습니다. 게다가 HTTP에서는 마이너 버전 업은 인터페이스의 하위 호환성을 보증하고 있습니다.



## 06. REST의 의미

REST는 웹 전체의 아키텍처 스타일입니다. 웹은 REST라는 분산 네트워크 시스템을 위한 이론이 있었기에 이만큼 성공했다고 말할 수 있습니다. 우리들이 만드는 웹 서비스나 웹 API는 웹을 구성하는 일부분입니다. 개별 웹 서비스와 웹 API가 RESTful이 되면, 웹은 전체적으로 더욱 좋아집니다.



